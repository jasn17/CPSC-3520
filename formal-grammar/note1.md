# *Language as a Sequence of Symbols*

"The cat sleeps."
Subject: "The cat" (Determiner + Noun)
Predicate: "sleeps" (Verb)

Programming language also follow structured rules defined by **formal grammar**
- Formal grammar define rules for constructing valid programs
- Compiler must recognize and process these sequences correctly
- Formal grammar help define valid syntax in programming languages

Like natural languages, programming languages have rules defining valid sequences

A regular C Code can appear in **single line format** without all the indentations

In Lisp:
```
(defun hello
    (print
        (cons 'Hello (list 'World))))
```

In single line format: 
(defun hello (print (cons 'Hello (list 'World))))

Programs are **structured symbol sequences**

---

# *Language Syntax Specifications and Productions*
A langauge syntax is using primative (reserved words) and productions (rules) and combining the two to form programs

In C:
```c
    void main(void) {
        char *message[] = {"Hello ", "World"};
        int i;
        for(i = 0; i < 2; ++i)
            printf("%s", message[i]);
        printf("\n");
    }
```
Single line version:
void main(void) { char *message[] = {"Hello ", "World"}; int i; for(i = 0; i < 2; ++i) printf("%s", message[i]); printf("\n"); }


In BNF:
``` 
    function - identifier ::= identifier
    identifier ::= letter{letter-or-digit}
    letter ::= a|b|c|...|z|A|...|Z
    digit ::= 0|1|...|9
    letter-or-digit ::= letter|digit
```
(This programs says "any *identifier* must start with a letter and can be followed by any number of letters or digits)

::= means "is defined as"
| means "or"
{} inidcates itmes that may be repeated >0 times

---

# *Compiler Role and Parsing*
- A compiler contains a parser (grammatical recognizer)
- It processes the input code as a string of symbols
- Parses the input using the formal grammar
- Checks if the input conforms to grammar rules

# *Alphabets and Strings*
*Alphabet (V)*: finite, nonempty set of symbols
Example: ```V = {a, b, c, d}```

String over V: sequence of symbols from V
Examples: ```a, ab, abc, aab```

String notation:
    Concatenation: a ◦ b = ab
    Length: |abc| = 3
    Repetition: a2b3c4 = aabbbcccc

---

# *Closure Sets*
V⁺ = all nonempty strings formed using symbols from V
V* = V⁺ ∪ {ε} = all possible strings including empty string
V* is denoted as a *Closure Set*


---

# *Languages from Strings*
A language L is a subset of V*: L ⊆ V*
Languages are generated by grammars
A grammar defines which strings from V* are in the language

---

# *Example Grammar*
```
S -> AB
A -> Ax | y
B -> z
```
Alphabet: V = {S, A, B, x, y, z}
S,A,B are non-terminal symbols
x,y,z are terminal symbols

### Explanation of Possible Strings:
1. **yz**:
    - Start with `S -> AB`.
    - `A -> y` (choose the production rule where `A` directly becomes `y`).
    - `B -> z`.
    - Combining these, `S -> AB -> yz`.

2. **yxz**:
    - Start with `S -> AB`.
    - `A -> Ax` (choose the production rule where `A` expands to `Ax`).
    - `A -> y` (now expand the remaining `A` to `y`).
    - `B -> z`.
    - Combining these, `S -> AB -> A(B) -> Ax(B) -> yx(B) -> yxz`.

3. **yyz**:
    - Start with `S -> AB`.
    - `A -> Ax` (choose the production rule where `A` expands to `Ax`).
    - `A -> y` (expand the remaining `A` to `y`).
    - `B -> z`.
    - Combining these, `S -> AB -> A(B) -> Ax(B) -> yx(B) -> yyz`.

4. **xxz**:
    - This string is **not valid** because:
      - According to the grammar, `A` must eventually resolve to `y` (it cannot remain as `Ax` indefinitely).
      - The string `xxz` implies that `A` was expanded to `Ax` multiple times without resolving to `y`, which violates the grammar rules.

### Summary:
The grammar enforces that `A` must eventually resolve to `y`, and `B` must always resolve to `z`. Strings like `yz`, `yxz`, and `yyz` are valid because they follow these rules. However, `xxz` is invalid as it does not conform to the requirement that `A` resolves to `y`.

### Another Example Grammar
```
S -> XY
X -> aX | b
Y -> cY | d
```
Alphabet: V = {S, X, Y, a, b, c, d}  
Non-terminal symbols: S, X, Y  
Terminal symbols: a, b, c, d  

### Explanation of Possible Strings:
1. **bc**:
    - Start with `S -> XY`.
    - `X -> b` (choose the production rule where `X` directly becomes `b`).
    - `Y -> c` (choose the production rule where `Y` directly becomes `c`).
    - Combining these, `S -> XY -> bc`.

2. **aacd**:
    X must generate: aa
    Y must generate: cd 

    X = aa?
        ```
        X -> aX
        aX -> aaX
        aaX → ??? No rule turns X into ε
        ```
    → Uh-oh! X must end with b. There’s no rule for X that produces ε.
        So you can't stop with aa AND you must eventually go to b
        So X can only generate:
        b, ab, aab, aaab

    - This string aacd is **not valid** under this grammar.

### Note:
The string `aacd` is **not valid** because `X` cannot resolve to just `aa` without ending in `b`. The grammar enforces that `X` must eventually resolve to `b`, making it impossible to derive `aacd`.

3. **ad**:
    - This string is **not valid** because:
      - According to the grammar, `X` must eventually resolve to `b`, but the string `ad` implies that `X` was resolved to `a` without further expansion, which violates the grammar rules.

4. **bcd**:
    - This string is **not valid** because:
      - According to the grammar, `Y` must eventually resolve to `d`, but the string `bcd` implies that `Y` was resolved to `c` without further expansion, which violates the grammar rules.

### Summary:
The grammar enforces that `X` must eventually resolve to `b` and `Y` must eventually resolve to `d`. Strings like `bc` and `aacd` are valid because they follow these rules. However, strings like `ad` and `bcd` are invalid as they do not conform to the requirement that `X` resolves to `b` and `Y` resolves to `d`.

# *Formal Defintion of Grammar*
A grammar G is defined as:
G = (VT, VN, P, S), where

VT = Terminal symbols (cannot be replaced)
VN = Non-terminal symbols (can be replaced)
P = Productions (rules)
S = Start symbol (S ∈ VN)

```
S -> XY
X -> aX | b
Y -> cY | d
V = {S, X, Y, a, b, c, d}
```
Terminals {S, X, Y}
Non-terminals {S, A, B}
Starting symbol: S


